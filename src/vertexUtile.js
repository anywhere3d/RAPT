var particleMaterial = new THREE.ShaderMaterial( {
            attributes:[ 'size', 'colors', 'customPos', 'angle' ],
            uniforms:{
                ntiles :  { type: 'f', value: 8.0 },
                scale :  { type: 'f', value: 60.0 },
                diffuse :  { type: 'c', value: new THREE.Color(1, 1, 1) },
                map: { type: 't', value: null }
            },
            fragmentShader:[
                  'uniform sampler2D map;',
                  'uniform vec3 diffuse;',
                  'uniform float ntiles;',
                  'varying vec4 vColor;',
                  'varying vec2 vPos;',
                  'varying float vAngle;',
                  'void main(){',
                  '    float mid = 0.5;',
                  '    float sinX = sin(vAngle);',
                  '    float cosX = cos(vAngle);',
                  '    vec2 pos = vPos;',
                  '    pos.y = ntiles-pos.y-1.0;',
                  '    vec2 sc = vec2(1.0/ntiles, 1.0/ntiles);',


                  '    vec2 uv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );',

                  
                  '    mat2 rotationMatrix = mat2( cosX, -sinX, sinX, cosX);',
                  '    rotationMatrix *= 0.5;',
                  '    rotationMatrix += 0.5;',
                  '    rotationMatrix = rotationMatrix * 2.0 -1.0;',
                  //'    vec2 coord = (uv*sc)+(pos*sc);',
                  '    uv -= mid;',
                  '    uv = uv*rotationMatrix;',
                  '    uv += mid;',

                  '    vec2 coord = (uv*sc)+(pos*sc);',
                  //'    coord -= mid;',

                  //'    coord = coord*rotationMatrix;',
                  //'    coord += mid;',
                  //'    coord.xy *= rotationMatrix;',
                  //'    coord = mul(coord, mat2(cos_factor, sin_factor, -sin_factor, cos_factor));',
                  //'    coord = (coord - mid) * mat2(cos_factor, sin_factor, -sin_factor, cos_factor);',
                  //'    coord += mid;',
                  '    vec4 tex = texture2D( map, coord );',
                  '    gl_FragColor = vec4(vColor.xyz*tex.xyz, vColor.a*tex.a);',
                  //'    gl_FragColor = vec4(vColor.xyz, vColor.a);',
                  '}'
            ].join('\n'),
            vertexShader:[    
                'attribute float angle;',
                'attribute vec4 colors;',
                'attribute vec2 customPos;',
                'attribute float size;',
                'uniform float scale;',
                'varying vec2 vPos;',
                'varying vec4 vColor;',
                'varying float vAngle;',

                /*'mat4 rotateAngle(float angle, vec3 axis) {',
                '  float c = cos(angle);',
                '  float s = sin(angle);',
                '  float t = 1.0 - c;',
                '  axis = normalize(axis);',
                '  float x = axis.x, y = axis.y, z = axis.z;',
                '  return mat4(',
                '    t*x*x + c,    t*x*y + s*z,  t*x*z - s*y, 0.0,', 
                '    t*x*y - s*z,  t*y*y + c,    t*y*z + s*x, 0.0,',
                '    t*x*z + s*y,  t*y*z - s*x,  t*z*z + c, 0.0,',
                '    0.0, 0.0, 0.0, 1.0',
                '  );',
                '}',

                'mat3 rotateAngleAxisMatrix(float angle, vec3 axis) {',
                '  float c = cos(angle);',
                '  float s = sin(angle);',
                '  float t = 1.0 - c;',
                '  axis = normalize(axis);',
                '  float x = axis.x, y = axis.y, z = axis.z;',
                '  return mat3(',
                '    t*x*x + c,    t*x*y + s*z,  t*x*z - s*y,',
                '    t*x*y - s*z,  t*y*y + c,    t*y*z + s*x,',
                '    t*x*z + s*y,  t*y*z - s*x,  t*z*z + c',
                '  );',
                '}',

                'vec3 rotateAngleAxis(float angle, vec3 axis, vec3 v) {',
                '   return rotateAngleAxisMatrix(angle, axis) * v;',
                '}',*/

                'void main(){',
                '    vPos = customPos;',
                '    vColor = colors;',
                '    vAngle = angle;',
                '    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );',
                '    gl_PointSize = size*scale;',
                '    gl_Position = projectionMatrix * mvPosition;',
                '}'
            ].join('\n'),
            //vertexColors:   THREE.VertexColors,
            depthTest: false,
            depthWrite: true,
            transparent: true
        });